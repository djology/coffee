MySQL架构与历史

    MySQL并不完美，却足够灵活，能够适应高要求的环境，同时，MySQL可以嵌入到应用程序中，也可以支持数据仓库、
    内容索引和部署软件、高可用的冗余系统、在线事务处理系统（OLTP）等各种应用类型

    MySQL最重要、最与众不同的特性是它的存储引擎架构，这种架构设计将查询处理（Query Processing）及其他系统任务
    （Server Task）和数据的存储/提取相分离。这种处理和存储分离的设计可以在使用时根据性能、特性，以及其他需求来
    选择数据存储的方式

1.1 MySQL逻辑架构

    最上层的服务并不是MySQL所特有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构，连接处理、授权
    认证、安全等

    第二层架构，大多数MySQL的核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数，所有跨
    存储引擎的功能都在这一层实现：存储过程、触发器、视图等

    第三层包括存储引擎，存储引擎负责MySQL中数据的存储和提取。存储引擎并不会解析SQL，不同的引擎间不会相互通信，
    而只是简单的响应上层服务器的请求

1.1.1 连接管理与安全性

    每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在单独的线程中执行，该线程只能轮流在某个CPU
    核心或者CPU中运行。服务器会负责缓存线程，因此不需要为每个新建的连接创建或销毁线程（MySQL服务器）

    当客户端连接到MySQL服务器时，服务器需要对其进行认证。认证基于用户名、原始主机信息和密码。
    如果使用安全套接字（SSL）的方式连接，还可以使用X.509证书认证

1.1.2 优化与执行

    MySQL会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及
    选择合适的索引等

    用户可以通过特殊的关键字提示（hint）优化器，影响它的决策过程，也可以请求优化器解释（explain）优化过程的各个因
    素，提供用户参考基准，便于用户重构查询和schema、修改相关配置

    优化器并不关心表使用的存储引擎，但存储引擎对优化查询是有影响的

1.2 并发控制

    无论何时，只要同一时刻进行有多个查询修改数据，都会触发并发控制的问题
    本处讨论两个层面的并发控制：服务器层，存储引擎层

1.2.1 读写锁

    在处理并发读或写时，可以通过实现由锁组成的锁系统解决
        共享锁（shared lock），读锁（read lock）
        排他锁（exclusive lock），写锁（write lock）

1.2.2 锁粒度

    更理想的方式是，只对会修改的数据片进行精确的锁定
    锁定的数据量越少，系统的并发程度越高

    加锁也需要消耗资源，锁的各种操作，获得锁，检查锁

    MySQL中提供多种选择，每种MySQL存储引擎都可以实现自己的锁策略和锁粒度

    表锁（table lock）
        MySQL中最基本的锁策略，且是开销最小的策略
    行级锁（row lock）
        最大程度支持并发处理，只在存储引擎层实现，在MySQL服务器层没有实现

1.3 事务

    ACID

1.3.1 隔离级别

    READ UNCOMMITTED（读未提交），触发脏读
    READ COMMITTED（读已提交），不可重复读
    REPEATABLE READ（可重复读），触发幻读
    SERIALIZABLE（可串行化）

1.3.2 死锁

    死锁，是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象
    为了解决这种问题，数据库系统实现了各种死锁检测和死锁超时机制
            InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚

1.3.3 事务日志

    事务日志可以帮助提高事务的效率，事务日志采用的是追加的方式，目前大多数的存储引擎都是这样实现的，修改数据需要
    写两次磁盘

    如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时当系统崩溃，存储引擎在重启时能够自动
    恢复这部分的修改，具体恢复方式依据存储引擎而定

1.3.4 MySQL中的事务

    MySQL中提供两种事务型的引擎：InnoDB，NDB Cluster

    隐式和显示锁定

        InnoDB采用的是两阶段锁定协议（two-phase locking protocol），锁在执行COMMIT或ROLLBACK时才会释放（这
        就是隐式锁定），InnoDB也支持通过特定语句进行的显示锁定（轮到切换引擎，需要考虑背后的事务处理，毕竟InnoDB
        的行级锁运行得不错）

1.4 多版本并发控制

    MySQL大多数事务型存储引擎实现的都不是简单的行级锁
    基于提升并发性能的考虑，它们一般都实现了多版本并发控制（MVCC）

    可以认为MVCC是行级锁的变种，但在很多情况下避免了加锁操作，开销更低。虽然实现机制有所不同，但大都实现了非阻
    塞的读操作，写操作只锁定必要的行

    MVCC的实现，是通过保存数据在某个时间点的快照来实现的

    InnoDB的MVCC，是通过在每行记录后保存两个隐藏列来实现的，一个保存行的创建时间，一个保存行的过期时间（或删除
    时间）。当然存储的并不是实际的时间值，是系统版本号（system version number）。开始新的事务，系统版本号自动递
    增，事务开始时的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行对比

1.5 MySQL的存储引擎

    在文件系统中，MySQL将每个数据库（schema）保存为数据目录下一个子目录
    创建表时，MySQL会在数据库子目录下创建一个与表同名的.frm文件保存表的定义

        show table status like 'dept' \G
                   Name: dept
                 Engine: InnoDB
                Version: 10
         Row_format: Dynamic
                   Rows: 4
  Avg_row_length: 4096
        Data_length: 16384
Max_data_length: 0
       Index_length: 0
             Data_free: 0
   Auto_increment: NULL
         Create_time: 2021-08-11 00:06:14
        Update_time: NULL
          Check_time: NULL
              Collation: utf8mb4_0900_ai_ci
            Checksum: NULL
     Create_options:
              Comment:

1.5.1 InnoDB存储引擎

    InnoDB的历史

        2008年发布的InnoDB plugin，适用于MySQL 5.1版本，这就是Oracle创建的下一代InnoDB引擎，其拥有者并不是MySQL
        MySQL默认选择集成旧版本的InnoDB，用户可以自行选择InnoDB plugin来覆盖旧的版本，直到Oracle收购MySQL，才
        在MySQL5.5中彻底使用InnoDB plugin替代了旧版本的InnoDB

    InnoDB概览

        InnoDB的数据存储在表空间（tablespace）中，表空间由一系列数据文件组成
        InnoDB采用MVCC支持高并发，并实现标准的隔离级别，默认级别是可重复读，并通过间隙锁（next-key locking）策
        略防止幻读的出现。间隙锁使得InnoDB不仅锁定查询涉及的行，还会对索引中的间隙进行锁定，防止幻影行的插入

        InnoDB表是基于聚簇索引建立的，聚簇索引对主键查询有很高的性能，不过二级索引（非主键索引）中必须包含主键列

        InnoDB中做了很多优化，包括从磁盘读取时采用的可预测性预读，能够自动在内存中创建hash索引以加速读操作的自适
        应哈希索引，以及能够加速插入操作的插入缓冲区等

1.5.2 MyISAM存储引擎

    在MySQL 5.1及以前的版本，MyISAM是默认的存储引擎
    MyISAM提供大量特性，包括全文索引、压缩、空间函数（GIS）等，但MyISAM不支持事务和行级锁

    存储

        MyISAM会将表存储在两个文件中：数据文件和索引文件

    MyISAM特性

        加锁与并发
            读取时施加共享锁，写入时施加排他锁
            在表读取查询时，也可以往表中插入新的记录（并发插入，CONCURRENT INSERT）
        修复
            MySQL可以手工或者自动执行检查和修复操作，不同于事务恢复和崩溃恢复
            执行表的修复可能会导致一些数据丢失，且慢
            可以通过CHECK TABLE mytable检查表的错误，执行REPAIR TABLE mytable进行修复
            也可以通过myisamchk命令行工具进行检查和修复操作
        索引特性
            可以对BLOB和CLOB长字段，创建基于其前500个字符的索引
            也支持全文索引
        延迟更新索引键
            指定DELAY_KEY_WRITE选项，在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是内存中的键缓冲区，
            只有在清理键缓冲区或关闭表的时候才会将对应的索引块写入到磁盘

    MyISAM压缩表

        表在创建并导入数据后，不再进行修改操作，或许较适合采用MyISAM压缩表
        使用myisampack对MyISAM表进行压缩，压缩后不能进行修改。压缩表可以极大地减少磁盘空间占用，减少磁盘I/O

    MyISAM性能

        MyISAM有一些服务器级别的性能扩展限制，最典型的性能问题还是表锁的限制

1.5.6 转换表的引擎

    ALTER TABLE

        mysql> ALTER TABLE mytable ENGINE = InnoDB;

        存在的问题是，需要执行很长时间，MySQL会按行将数据从原表复制到一张新表中，期间会消耗系统所有的I/O能力，同时
        原表上会加上读锁
        如果转换表的存储引擎，将会失去和原引擎相关的所有特性

    导入导出

        使用mysqldump工具将数据导出到文件，然后修改文件中CREATE TABLE语句的存储引擎选项

    创建与查询（CREATE和SELECT）

1.6 MySQL时间线

    3.23（2001）
        引入MyISAM代替诸多限制的ISAM引擎，支持全文索引和复制（复制是MySQL的killer feature）

    4.0（2003）
        支持UNION和多表DELETE，InnoDB成为标配
        还引入查询缓存，和支持通过SSL进行连接

    4.1（2005）
        引入更多语法：子查询和INSERT ON DUPLICATE KEY UPDATE
        开始支持UTF-8

    5.0（2006）
        出现企业级特性：视图，触发器，存储过程和存储函数

    5.1（2008）
        被SUN收购后首个版本
        引入分区，基于行的复制，以及plugin API
        同时Oracle收购的InnoDB Oy发布了InnoDB plugin

    5.5（2010）
        Oracle收购SUN后首个版本
        改善性能、扩展性、复制、分区，和对Windows的支持
        InnoDB成为默认的存储引擎
